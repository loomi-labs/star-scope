// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/loomi-labs/star-scope/ent/chain"
	"github.com/loomi-labs/star-scope/ent/predicate"
	"github.com/loomi-labs/star-scope/ent/user"
	"github.com/loomi-labs/star-scope/ent/usersetup"
	"github.com/loomi-labs/star-scope/ent/validator"
)

// UserSetupUpdate is the builder for updating UserSetup entities.
type UserSetupUpdate struct {
	config
	hooks    []Hook
	mutation *UserSetupMutation
}

// Where appends a list predicates to the UserSetupUpdate builder.
func (usu *UserSetupUpdate) Where(ps ...predicate.UserSetup) *UserSetupUpdate {
	usu.mutation.Where(ps...)
	return usu
}

// SetUpdateTime sets the "update_time" field.
func (usu *UserSetupUpdate) SetUpdateTime(t time.Time) *UserSetupUpdate {
	usu.mutation.SetUpdateTime(t)
	return usu
}

// SetStep sets the "step" field.
func (usu *UserSetupUpdate) SetStep(u usersetup.Step) *UserSetupUpdate {
	usu.mutation.SetStep(u)
	return usu
}

// SetNillableStep sets the "step" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableStep(u *usersetup.Step) *UserSetupUpdate {
	if u != nil {
		usu.SetStep(*u)
	}
	return usu
}

// SetIsValidator sets the "is_validator" field.
func (usu *UserSetupUpdate) SetIsValidator(b bool) *UserSetupUpdate {
	usu.mutation.SetIsValidator(b)
	return usu
}

// SetNillableIsValidator sets the "is_validator" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableIsValidator(b *bool) *UserSetupUpdate {
	if b != nil {
		usu.SetIsValidator(*b)
	}
	return usu
}

// SetWalletAddresses sets the "wallet_addresses" field.
func (usu *UserSetupUpdate) SetWalletAddresses(s []string) *UserSetupUpdate {
	usu.mutation.SetWalletAddresses(s)
	return usu
}

// AppendWalletAddresses appends s to the "wallet_addresses" field.
func (usu *UserSetupUpdate) AppendWalletAddresses(s []string) *UserSetupUpdate {
	usu.mutation.AppendWalletAddresses(s)
	return usu
}

// ClearWalletAddresses clears the value of the "wallet_addresses" field.
func (usu *UserSetupUpdate) ClearWalletAddresses() *UserSetupUpdate {
	usu.mutation.ClearWalletAddresses()
	return usu
}

// SetNotifyFunding sets the "notify_funding" field.
func (usu *UserSetupUpdate) SetNotifyFunding(b bool) *UserSetupUpdate {
	usu.mutation.SetNotifyFunding(b)
	return usu
}

// SetNillableNotifyFunding sets the "notify_funding" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableNotifyFunding(b *bool) *UserSetupUpdate {
	if b != nil {
		usu.SetNotifyFunding(*b)
	}
	return usu
}

// SetNotifyStaking sets the "notify_staking" field.
func (usu *UserSetupUpdate) SetNotifyStaking(b bool) *UserSetupUpdate {
	usu.mutation.SetNotifyStaking(b)
	return usu
}

// SetNillableNotifyStaking sets the "notify_staking" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableNotifyStaking(b *bool) *UserSetupUpdate {
	if b != nil {
		usu.SetNotifyStaking(*b)
	}
	return usu
}

// SetNotifyGovNewProposal sets the "notify_gov_new_proposal" field.
func (usu *UserSetupUpdate) SetNotifyGovNewProposal(b bool) *UserSetupUpdate {
	usu.mutation.SetNotifyGovNewProposal(b)
	return usu
}

// SetNillableNotifyGovNewProposal sets the "notify_gov_new_proposal" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableNotifyGovNewProposal(b *bool) *UserSetupUpdate {
	if b != nil {
		usu.SetNotifyGovNewProposal(*b)
	}
	return usu
}

// SetNotifyGovVotingEnd sets the "notify_gov_voting_end" field.
func (usu *UserSetupUpdate) SetNotifyGovVotingEnd(b bool) *UserSetupUpdate {
	usu.mutation.SetNotifyGovVotingEnd(b)
	return usu
}

// SetNillableNotifyGovVotingEnd sets the "notify_gov_voting_end" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableNotifyGovVotingEnd(b *bool) *UserSetupUpdate {
	if b != nil {
		usu.SetNotifyGovVotingEnd(*b)
	}
	return usu
}

// SetNotifyGovVotingReminder sets the "notify_gov_voting_reminder" field.
func (usu *UserSetupUpdate) SetNotifyGovVotingReminder(b bool) *UserSetupUpdate {
	usu.mutation.SetNotifyGovVotingReminder(b)
	return usu
}

// SetNillableNotifyGovVotingReminder sets the "notify_gov_voting_reminder" field if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableNotifyGovVotingReminder(b *bool) *UserSetupUpdate {
	if b != nil {
		usu.SetNotifyGovVotingReminder(*b)
	}
	return usu
}

// SetUserID sets the "user" edge to the User entity by ID.
func (usu *UserSetupUpdate) SetUserID(id int) *UserSetupUpdate {
	usu.mutation.SetUserID(id)
	return usu
}

// SetNillableUserID sets the "user" edge to the User entity by ID if the given value is not nil.
func (usu *UserSetupUpdate) SetNillableUserID(id *int) *UserSetupUpdate {
	if id != nil {
		usu = usu.SetUserID(*id)
	}
	return usu
}

// SetUser sets the "user" edge to the User entity.
func (usu *UserSetupUpdate) SetUser(u *User) *UserSetupUpdate {
	return usu.SetUserID(u.ID)
}

// AddSelectedValidatorIDs adds the "selected_validators" edge to the Validator entity by IDs.
func (usu *UserSetupUpdate) AddSelectedValidatorIDs(ids ...int) *UserSetupUpdate {
	usu.mutation.AddSelectedValidatorIDs(ids...)
	return usu
}

// AddSelectedValidators adds the "selected_validators" edges to the Validator entity.
func (usu *UserSetupUpdate) AddSelectedValidators(v ...*Validator) *UserSetupUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return usu.AddSelectedValidatorIDs(ids...)
}

// AddSelectedChainIDs adds the "selected_chains" edge to the Chain entity by IDs.
func (usu *UserSetupUpdate) AddSelectedChainIDs(ids ...int) *UserSetupUpdate {
	usu.mutation.AddSelectedChainIDs(ids...)
	return usu
}

// AddSelectedChains adds the "selected_chains" edges to the Chain entity.
func (usu *UserSetupUpdate) AddSelectedChains(c ...*Chain) *UserSetupUpdate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return usu.AddSelectedChainIDs(ids...)
}

// Mutation returns the UserSetupMutation object of the builder.
func (usu *UserSetupUpdate) Mutation() *UserSetupMutation {
	return usu.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (usu *UserSetupUpdate) ClearUser() *UserSetupUpdate {
	usu.mutation.ClearUser()
	return usu
}

// ClearSelectedValidators clears all "selected_validators" edges to the Validator entity.
func (usu *UserSetupUpdate) ClearSelectedValidators() *UserSetupUpdate {
	usu.mutation.ClearSelectedValidators()
	return usu
}

// RemoveSelectedValidatorIDs removes the "selected_validators" edge to Validator entities by IDs.
func (usu *UserSetupUpdate) RemoveSelectedValidatorIDs(ids ...int) *UserSetupUpdate {
	usu.mutation.RemoveSelectedValidatorIDs(ids...)
	return usu
}

// RemoveSelectedValidators removes "selected_validators" edges to Validator entities.
func (usu *UserSetupUpdate) RemoveSelectedValidators(v ...*Validator) *UserSetupUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return usu.RemoveSelectedValidatorIDs(ids...)
}

// ClearSelectedChains clears all "selected_chains" edges to the Chain entity.
func (usu *UserSetupUpdate) ClearSelectedChains() *UserSetupUpdate {
	usu.mutation.ClearSelectedChains()
	return usu
}

// RemoveSelectedChainIDs removes the "selected_chains" edge to Chain entities by IDs.
func (usu *UserSetupUpdate) RemoveSelectedChainIDs(ids ...int) *UserSetupUpdate {
	usu.mutation.RemoveSelectedChainIDs(ids...)
	return usu
}

// RemoveSelectedChains removes "selected_chains" edges to Chain entities.
func (usu *UserSetupUpdate) RemoveSelectedChains(c ...*Chain) *UserSetupUpdate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return usu.RemoveSelectedChainIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (usu *UserSetupUpdate) Save(ctx context.Context) (int, error) {
	usu.defaults()
	return withHooks(ctx, usu.sqlSave, usu.mutation, usu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (usu *UserSetupUpdate) SaveX(ctx context.Context) int {
	affected, err := usu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (usu *UserSetupUpdate) Exec(ctx context.Context) error {
	_, err := usu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (usu *UserSetupUpdate) ExecX(ctx context.Context) {
	if err := usu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (usu *UserSetupUpdate) defaults() {
	if _, ok := usu.mutation.UpdateTime(); !ok {
		v := usersetup.UpdateDefaultUpdateTime()
		usu.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (usu *UserSetupUpdate) check() error {
	if v, ok := usu.mutation.Step(); ok {
		if err := usersetup.StepValidator(v); err != nil {
			return &ValidationError{Name: "step", err: fmt.Errorf(`ent: validator failed for field "UserSetup.step": %w`, err)}
		}
	}
	return nil
}

func (usu *UserSetupUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := usu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(usersetup.Table, usersetup.Columns, sqlgraph.NewFieldSpec(usersetup.FieldID, field.TypeInt))
	if ps := usu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := usu.mutation.UpdateTime(); ok {
		_spec.SetField(usersetup.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := usu.mutation.Step(); ok {
		_spec.SetField(usersetup.FieldStep, field.TypeEnum, value)
	}
	if value, ok := usu.mutation.IsValidator(); ok {
		_spec.SetField(usersetup.FieldIsValidator, field.TypeBool, value)
	}
	if value, ok := usu.mutation.WalletAddresses(); ok {
		_spec.SetField(usersetup.FieldWalletAddresses, field.TypeJSON, value)
	}
	if value, ok := usu.mutation.AppendedWalletAddresses(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, usersetup.FieldWalletAddresses, value)
		})
	}
	if usu.mutation.WalletAddressesCleared() {
		_spec.ClearField(usersetup.FieldWalletAddresses, field.TypeJSON)
	}
	if value, ok := usu.mutation.NotifyFunding(); ok {
		_spec.SetField(usersetup.FieldNotifyFunding, field.TypeBool, value)
	}
	if value, ok := usu.mutation.NotifyStaking(); ok {
		_spec.SetField(usersetup.FieldNotifyStaking, field.TypeBool, value)
	}
	if value, ok := usu.mutation.NotifyGovNewProposal(); ok {
		_spec.SetField(usersetup.FieldNotifyGovNewProposal, field.TypeBool, value)
	}
	if value, ok := usu.mutation.NotifyGovVotingEnd(); ok {
		_spec.SetField(usersetup.FieldNotifyGovVotingEnd, field.TypeBool, value)
	}
	if value, ok := usu.mutation.NotifyGovVotingReminder(); ok {
		_spec.SetField(usersetup.FieldNotifyGovVotingReminder, field.TypeBool, value)
	}
	if usu.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   usersetup.UserTable,
			Columns: []string{usersetup.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usu.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   usersetup.UserTable,
			Columns: []string{usersetup.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if usu.mutation.SelectedValidatorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedValidatorsTable,
			Columns: usersetup.SelectedValidatorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(validator.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usu.mutation.RemovedSelectedValidatorsIDs(); len(nodes) > 0 && !usu.mutation.SelectedValidatorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedValidatorsTable,
			Columns: usersetup.SelectedValidatorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(validator.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usu.mutation.SelectedValidatorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedValidatorsTable,
			Columns: usersetup.SelectedValidatorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(validator.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if usu.mutation.SelectedChainsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedChainsTable,
			Columns: usersetup.SelectedChainsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chain.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usu.mutation.RemovedSelectedChainsIDs(); len(nodes) > 0 && !usu.mutation.SelectedChainsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedChainsTable,
			Columns: usersetup.SelectedChainsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chain.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usu.mutation.SelectedChainsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedChainsTable,
			Columns: usersetup.SelectedChainsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chain.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, usu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{usersetup.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	usu.mutation.done = true
	return n, nil
}

// UserSetupUpdateOne is the builder for updating a single UserSetup entity.
type UserSetupUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *UserSetupMutation
}

// SetUpdateTime sets the "update_time" field.
func (usuo *UserSetupUpdateOne) SetUpdateTime(t time.Time) *UserSetupUpdateOne {
	usuo.mutation.SetUpdateTime(t)
	return usuo
}

// SetStep sets the "step" field.
func (usuo *UserSetupUpdateOne) SetStep(u usersetup.Step) *UserSetupUpdateOne {
	usuo.mutation.SetStep(u)
	return usuo
}

// SetNillableStep sets the "step" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableStep(u *usersetup.Step) *UserSetupUpdateOne {
	if u != nil {
		usuo.SetStep(*u)
	}
	return usuo
}

// SetIsValidator sets the "is_validator" field.
func (usuo *UserSetupUpdateOne) SetIsValidator(b bool) *UserSetupUpdateOne {
	usuo.mutation.SetIsValidator(b)
	return usuo
}

// SetNillableIsValidator sets the "is_validator" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableIsValidator(b *bool) *UserSetupUpdateOne {
	if b != nil {
		usuo.SetIsValidator(*b)
	}
	return usuo
}

// SetWalletAddresses sets the "wallet_addresses" field.
func (usuo *UserSetupUpdateOne) SetWalletAddresses(s []string) *UserSetupUpdateOne {
	usuo.mutation.SetWalletAddresses(s)
	return usuo
}

// AppendWalletAddresses appends s to the "wallet_addresses" field.
func (usuo *UserSetupUpdateOne) AppendWalletAddresses(s []string) *UserSetupUpdateOne {
	usuo.mutation.AppendWalletAddresses(s)
	return usuo
}

// ClearWalletAddresses clears the value of the "wallet_addresses" field.
func (usuo *UserSetupUpdateOne) ClearWalletAddresses() *UserSetupUpdateOne {
	usuo.mutation.ClearWalletAddresses()
	return usuo
}

// SetNotifyFunding sets the "notify_funding" field.
func (usuo *UserSetupUpdateOne) SetNotifyFunding(b bool) *UserSetupUpdateOne {
	usuo.mutation.SetNotifyFunding(b)
	return usuo
}

// SetNillableNotifyFunding sets the "notify_funding" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableNotifyFunding(b *bool) *UserSetupUpdateOne {
	if b != nil {
		usuo.SetNotifyFunding(*b)
	}
	return usuo
}

// SetNotifyStaking sets the "notify_staking" field.
func (usuo *UserSetupUpdateOne) SetNotifyStaking(b bool) *UserSetupUpdateOne {
	usuo.mutation.SetNotifyStaking(b)
	return usuo
}

// SetNillableNotifyStaking sets the "notify_staking" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableNotifyStaking(b *bool) *UserSetupUpdateOne {
	if b != nil {
		usuo.SetNotifyStaking(*b)
	}
	return usuo
}

// SetNotifyGovNewProposal sets the "notify_gov_new_proposal" field.
func (usuo *UserSetupUpdateOne) SetNotifyGovNewProposal(b bool) *UserSetupUpdateOne {
	usuo.mutation.SetNotifyGovNewProposal(b)
	return usuo
}

// SetNillableNotifyGovNewProposal sets the "notify_gov_new_proposal" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableNotifyGovNewProposal(b *bool) *UserSetupUpdateOne {
	if b != nil {
		usuo.SetNotifyGovNewProposal(*b)
	}
	return usuo
}

// SetNotifyGovVotingEnd sets the "notify_gov_voting_end" field.
func (usuo *UserSetupUpdateOne) SetNotifyGovVotingEnd(b bool) *UserSetupUpdateOne {
	usuo.mutation.SetNotifyGovVotingEnd(b)
	return usuo
}

// SetNillableNotifyGovVotingEnd sets the "notify_gov_voting_end" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableNotifyGovVotingEnd(b *bool) *UserSetupUpdateOne {
	if b != nil {
		usuo.SetNotifyGovVotingEnd(*b)
	}
	return usuo
}

// SetNotifyGovVotingReminder sets the "notify_gov_voting_reminder" field.
func (usuo *UserSetupUpdateOne) SetNotifyGovVotingReminder(b bool) *UserSetupUpdateOne {
	usuo.mutation.SetNotifyGovVotingReminder(b)
	return usuo
}

// SetNillableNotifyGovVotingReminder sets the "notify_gov_voting_reminder" field if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableNotifyGovVotingReminder(b *bool) *UserSetupUpdateOne {
	if b != nil {
		usuo.SetNotifyGovVotingReminder(*b)
	}
	return usuo
}

// SetUserID sets the "user" edge to the User entity by ID.
func (usuo *UserSetupUpdateOne) SetUserID(id int) *UserSetupUpdateOne {
	usuo.mutation.SetUserID(id)
	return usuo
}

// SetNillableUserID sets the "user" edge to the User entity by ID if the given value is not nil.
func (usuo *UserSetupUpdateOne) SetNillableUserID(id *int) *UserSetupUpdateOne {
	if id != nil {
		usuo = usuo.SetUserID(*id)
	}
	return usuo
}

// SetUser sets the "user" edge to the User entity.
func (usuo *UserSetupUpdateOne) SetUser(u *User) *UserSetupUpdateOne {
	return usuo.SetUserID(u.ID)
}

// AddSelectedValidatorIDs adds the "selected_validators" edge to the Validator entity by IDs.
func (usuo *UserSetupUpdateOne) AddSelectedValidatorIDs(ids ...int) *UserSetupUpdateOne {
	usuo.mutation.AddSelectedValidatorIDs(ids...)
	return usuo
}

// AddSelectedValidators adds the "selected_validators" edges to the Validator entity.
func (usuo *UserSetupUpdateOne) AddSelectedValidators(v ...*Validator) *UserSetupUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return usuo.AddSelectedValidatorIDs(ids...)
}

// AddSelectedChainIDs adds the "selected_chains" edge to the Chain entity by IDs.
func (usuo *UserSetupUpdateOne) AddSelectedChainIDs(ids ...int) *UserSetupUpdateOne {
	usuo.mutation.AddSelectedChainIDs(ids...)
	return usuo
}

// AddSelectedChains adds the "selected_chains" edges to the Chain entity.
func (usuo *UserSetupUpdateOne) AddSelectedChains(c ...*Chain) *UserSetupUpdateOne {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return usuo.AddSelectedChainIDs(ids...)
}

// Mutation returns the UserSetupMutation object of the builder.
func (usuo *UserSetupUpdateOne) Mutation() *UserSetupMutation {
	return usuo.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (usuo *UserSetupUpdateOne) ClearUser() *UserSetupUpdateOne {
	usuo.mutation.ClearUser()
	return usuo
}

// ClearSelectedValidators clears all "selected_validators" edges to the Validator entity.
func (usuo *UserSetupUpdateOne) ClearSelectedValidators() *UserSetupUpdateOne {
	usuo.mutation.ClearSelectedValidators()
	return usuo
}

// RemoveSelectedValidatorIDs removes the "selected_validators" edge to Validator entities by IDs.
func (usuo *UserSetupUpdateOne) RemoveSelectedValidatorIDs(ids ...int) *UserSetupUpdateOne {
	usuo.mutation.RemoveSelectedValidatorIDs(ids...)
	return usuo
}

// RemoveSelectedValidators removes "selected_validators" edges to Validator entities.
func (usuo *UserSetupUpdateOne) RemoveSelectedValidators(v ...*Validator) *UserSetupUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return usuo.RemoveSelectedValidatorIDs(ids...)
}

// ClearSelectedChains clears all "selected_chains" edges to the Chain entity.
func (usuo *UserSetupUpdateOne) ClearSelectedChains() *UserSetupUpdateOne {
	usuo.mutation.ClearSelectedChains()
	return usuo
}

// RemoveSelectedChainIDs removes the "selected_chains" edge to Chain entities by IDs.
func (usuo *UserSetupUpdateOne) RemoveSelectedChainIDs(ids ...int) *UserSetupUpdateOne {
	usuo.mutation.RemoveSelectedChainIDs(ids...)
	return usuo
}

// RemoveSelectedChains removes "selected_chains" edges to Chain entities.
func (usuo *UserSetupUpdateOne) RemoveSelectedChains(c ...*Chain) *UserSetupUpdateOne {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return usuo.RemoveSelectedChainIDs(ids...)
}

// Where appends a list predicates to the UserSetupUpdate builder.
func (usuo *UserSetupUpdateOne) Where(ps ...predicate.UserSetup) *UserSetupUpdateOne {
	usuo.mutation.Where(ps...)
	return usuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (usuo *UserSetupUpdateOne) Select(field string, fields ...string) *UserSetupUpdateOne {
	usuo.fields = append([]string{field}, fields...)
	return usuo
}

// Save executes the query and returns the updated UserSetup entity.
func (usuo *UserSetupUpdateOne) Save(ctx context.Context) (*UserSetup, error) {
	usuo.defaults()
	return withHooks(ctx, usuo.sqlSave, usuo.mutation, usuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (usuo *UserSetupUpdateOne) SaveX(ctx context.Context) *UserSetup {
	node, err := usuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (usuo *UserSetupUpdateOne) Exec(ctx context.Context) error {
	_, err := usuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (usuo *UserSetupUpdateOne) ExecX(ctx context.Context) {
	if err := usuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (usuo *UserSetupUpdateOne) defaults() {
	if _, ok := usuo.mutation.UpdateTime(); !ok {
		v := usersetup.UpdateDefaultUpdateTime()
		usuo.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (usuo *UserSetupUpdateOne) check() error {
	if v, ok := usuo.mutation.Step(); ok {
		if err := usersetup.StepValidator(v); err != nil {
			return &ValidationError{Name: "step", err: fmt.Errorf(`ent: validator failed for field "UserSetup.step": %w`, err)}
		}
	}
	return nil
}

func (usuo *UserSetupUpdateOne) sqlSave(ctx context.Context) (_node *UserSetup, err error) {
	if err := usuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(usersetup.Table, usersetup.Columns, sqlgraph.NewFieldSpec(usersetup.FieldID, field.TypeInt))
	id, ok := usuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "UserSetup.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := usuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, usersetup.FieldID)
		for _, f := range fields {
			if !usersetup.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != usersetup.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := usuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := usuo.mutation.UpdateTime(); ok {
		_spec.SetField(usersetup.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := usuo.mutation.Step(); ok {
		_spec.SetField(usersetup.FieldStep, field.TypeEnum, value)
	}
	if value, ok := usuo.mutation.IsValidator(); ok {
		_spec.SetField(usersetup.FieldIsValidator, field.TypeBool, value)
	}
	if value, ok := usuo.mutation.WalletAddresses(); ok {
		_spec.SetField(usersetup.FieldWalletAddresses, field.TypeJSON, value)
	}
	if value, ok := usuo.mutation.AppendedWalletAddresses(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, usersetup.FieldWalletAddresses, value)
		})
	}
	if usuo.mutation.WalletAddressesCleared() {
		_spec.ClearField(usersetup.FieldWalletAddresses, field.TypeJSON)
	}
	if value, ok := usuo.mutation.NotifyFunding(); ok {
		_spec.SetField(usersetup.FieldNotifyFunding, field.TypeBool, value)
	}
	if value, ok := usuo.mutation.NotifyStaking(); ok {
		_spec.SetField(usersetup.FieldNotifyStaking, field.TypeBool, value)
	}
	if value, ok := usuo.mutation.NotifyGovNewProposal(); ok {
		_spec.SetField(usersetup.FieldNotifyGovNewProposal, field.TypeBool, value)
	}
	if value, ok := usuo.mutation.NotifyGovVotingEnd(); ok {
		_spec.SetField(usersetup.FieldNotifyGovVotingEnd, field.TypeBool, value)
	}
	if value, ok := usuo.mutation.NotifyGovVotingReminder(); ok {
		_spec.SetField(usersetup.FieldNotifyGovVotingReminder, field.TypeBool, value)
	}
	if usuo.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   usersetup.UserTable,
			Columns: []string{usersetup.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usuo.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   usersetup.UserTable,
			Columns: []string{usersetup.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if usuo.mutation.SelectedValidatorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedValidatorsTable,
			Columns: usersetup.SelectedValidatorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(validator.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usuo.mutation.RemovedSelectedValidatorsIDs(); len(nodes) > 0 && !usuo.mutation.SelectedValidatorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedValidatorsTable,
			Columns: usersetup.SelectedValidatorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(validator.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usuo.mutation.SelectedValidatorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedValidatorsTable,
			Columns: usersetup.SelectedValidatorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(validator.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if usuo.mutation.SelectedChainsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedChainsTable,
			Columns: usersetup.SelectedChainsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chain.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usuo.mutation.RemovedSelectedChainsIDs(); len(nodes) > 0 && !usuo.mutation.SelectedChainsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedChainsTable,
			Columns: usersetup.SelectedChainsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chain.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := usuo.mutation.SelectedChainsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   usersetup.SelectedChainsTable,
			Columns: usersetup.SelectedChainsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chain.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &UserSetup{config: usuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, usuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{usersetup.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	usuo.mutation.done = true
	return _node, nil
}
